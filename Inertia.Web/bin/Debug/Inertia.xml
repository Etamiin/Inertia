<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Inertia</name>
    </assembly>
    <members>
        <member name="T:Inertia.TypeNonSerializableException`1">
            <summary>
            This exception is thrown when trying to serialize a non-serializable object
            </summary>
        </member>
        <member name="P:Inertia.TypeNonSerializableException`1.Message">
            <summary>
            Message of the exception
            </summary>
        </member>
        <member name="P:Inertia.TypeNonSerializableException`1.Value">
            <summary>
            Object that caused the exception
            </summary>
        </member>
        <member name="M:Inertia.TypeNonSerializableException`1.#ctor(`0)">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.TypeNonSerializableException`1"/>
            </summary>
            <param name="value">The value that caused the exception</param>
        </member>
        <member name="T:Inertia.InertiaPlugin">
            <summary>
            Represent a plugin
            </summary>
        </member>
        <member name="M:Inertia.InertiaPlugin.OnInitialize">
            <summary>
            Initializaiton method for the plugin
            </summary>
        </member>
        <member name="M:Inertia.InertiaPlugin.OnExecute">
            <summary>
            Execution method for the plugin (after all plugins are initialized)
            </summary>
        </member>
        <member name="T:Inertia.PluginManager">
            <summary>
            
            </summary>
        </member>
        <member name="M:Inertia.PluginManager.ReloadPlugins">
            <summary>
            Reload all the plugins in memory
            </summary>
        </member>
        <member name="M:Inertia.PluginManager.GetPlugin``1">
            <summary>
            Return the specified Type of <see cref="T:Inertia.InertiaPlugin"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Inertia.BaseLogger">
            <summary>
            Represent the default class for displaying logs
            </summary>
        </member>
        <member name="P:Inertia.BaseLogger.MaxCacheCount">
            <summary>
            Specify max saved log count (100 by default)
            </summary>
        </member>
        <member name="P:Inertia.BaseLogger.AutoSaveCacheOnMaxCount">
            <summary>
            Specify if the <see cref="M:Inertia.BaseLogger.SaveCache"/> method is auto called when max cache capacity (<see cref="P:Inertia.BaseLogger.MaxCacheCount"/>) is reached
            </summary>
        </member>
        <member name="M:Inertia.BaseLogger.SetDefaultLogger``1">
            <summary>
            Set the specified <see cref="T:Inertia.BaseLogger"/> logger used as default
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Inertia.BaseLogger.AddLoggerPattern(System.String,BasicAction{System.String})">
            <summary>
            Register a new log pattern that can be used for logs
            </summary>
            <param name="type">Pattern type</param>
            <param name="onMessage"><see cref="T:BasicAction"/> to execute when a new log is create</param>
        </member>
        <member name="M:Inertia.BaseLogger.SaveCache">
            <summary>
            Manually save cache
            </summary>
        </member>
        <member name="M:Inertia.BaseLogger.#ctor">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.BaseLogger"/>
            </summary>
        </member>
        <member name="M:Inertia.BaseLogger.OnInitialized">
            <summary>
            This method is called when the class is instantiated
            </summary>
        </member>
        <member name="M:Inertia.BaseLogger.Log(System.Object,System.Object[])">
            <summary>
            Call first pattern and use it to log (if exist)
            </summary>
            <param name="log">The string content of the log</param>
            <param name="parameters">The parameters used to parse the string content</param>
        </member>
        <member name="M:Inertia.BaseLogger.LogPattern(System.String,System.Object,System.Object[])">
            <summary>
            Call specified pattern and use it to log
            </summary>
            <param name="patternType">Pattern's type to use <see cref="M:Inertia.BaseLogger.AddLoggerPattern(System.String,BasicAction{System.String})"/></param>
            <param name="log">The string content of the log</param>
            <param name="parameters">The parameters used to parse the string content</param>
        </member>
        <member name="T:Inertia.ConsoleLogger">
            <summary>
            Represent the logger for the <see cref="T:System.Console"/>
            </summary>
        </member>
        <member name="M:Inertia.ConsoleLogger.OnInitialized">
            <summary>
            Initialize the current instance of <see cref="T:Inertia.ConsoleLogger"/>
            </summary>
        </member>
        <member name="T:Inertia.InertiaExtensions">
            <summary>
            Contains all the library extension
            </summary>
        </member>
        <member name="M:Inertia.InertiaExtensions.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Shuffle the list
            </summary>
            <typeparam name="T">Type of element</typeparam>
            <param name="collection">List to shuffle</param>
        </member>
        <member name="M:Inertia.InertiaExtensions.GetSHA256(System.String)">
            <summary>
            Get the SHA256 key representation of the specified string 
            </summary>
            <param name="text">Target string</param>
            <returns></returns>
        </member>
        <member name="M:Inertia.InertiaExtensions.GetSHA256(System.String,System.Text.Encoding)">
            <summary>
            Get the SHA256 key representation of the specified string
            </summary>
            <param name="text">Target string</param>
            <param name="encoding">Target <see cref="T:System.Text.Encoding"/> algorithm to use</param>
            <returns></returns>
        </member>
        <member name="M:Inertia.InertiaExtensions.GetLogger(System.Object)">
            <summary>
            Get the current logger used (<see cref="P:Inertia.BaseLogger.DefaultLogger"/>)
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Inertia.InertiaExtensions.Compress(System.Byte[],System.Boolean@)">
            <summary>
            Compress the specified byte array and return the compressed one
            </summary>
            <param name="data">Target byte array to compress</param>
            <param name="compressed">Return true if the returned data is lower in length than the non-compressed data</param>
            <returns>Compressed byte array</returns>
        </member>
        <member name="M:Inertia.InertiaExtensions.Decompress(System.Byte[])">
            <summary>
            Decompress the specified byte array and return the decompressed one
            </summary>
            <param name="compressedData">Target byte array to decompress</param>
            <returns>Decompressed byte array</returns>
        </member>
        <member name="M:Inertia.InertiaExtensions.EncryptWithString(System.Byte[],System.String)">
            <summary>
            Encrypt the target byte array with the specified string key
            </summary>
            <param name="data">Target byte array to encrypt</param>
            <param name="key">Target string key for encryption</param>
            <returns>Encrypted byte array</returns>
        </member>
        <member name="M:Inertia.InertiaExtensions.DecryptWithString(System.Byte[],System.String)">
            <summary>
            Encrypt the target byte array with the specified string key
            </summary>
            <param name="encryptedData">Target byte array to encrypt</param>
            <param name="key">Target string key for encryption</param>
            <returns>Decrypted byte array</returns>
        </member>
        <member name="T:Inertia.Network.NetTcpClient">
            <summary>
            Represent the TCP client
            </summary>
        </member>
        <member name="P:Inertia.Network.NetTcpClient.IsConnected">
            <summary>
            Return true if the client is connected
            </summary>
        </member>
        <member name="M:Inertia.Network.NetTcpClient.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Network.NetTcpClient"/>
            </summary>
            <param name="ip">Ip to use</param>
            <param name="port">Port to use</param>
        </member>
        <member name="M:Inertia.Network.NetTcpClient.Connect">
            <summary>
            Connect the client
            </summary>
        </member>
        <member name="M:Inertia.Network.NetTcpClient.Disconnect(Inertia.Network.NetworkDisconnectReason)">
            <summary>
            Disconnect the client
            </summary>
            <param name="reason">Reason for disconnection</param>
        </member>
        <member name="M:Inertia.Network.NetTcpClient.Send(System.Byte[])">
            <summary>
            Send the specified byte array to the server
            </summary>
            <param name="data">Byte array to send</param>
        </member>
        <member name="M:Inertia.Network.NetTcpClient.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Network.NetTcpServer">
            <summary>
            Represent the TCP server
            </summary>
        </member>
        <member name="E:Inertia.Network.NetTcpServer.ClientConnected">
            <summary>
            Occurs when a new client is connected
            </summary>
        </member>
        <member name="E:Inertia.Network.NetTcpServer.ClientDisconnected">
            <summary>
            Occurs when a client disconnect
            </summary>
        </member>
        <member name="P:Inertia.Network.NetTcpServer.IsRunning">
            <summary>
            Return true if the server is started
            </summary>
        </member>
        <member name="M:Inertia.Network.NetTcpServer.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Network.NetTcpServer"/>
            </summary>
            <param name="ip">Ip to use</param>
            <param name="port">Port to use</param>
        </member>
        <member name="M:Inertia.Network.NetTcpServer.Start">
            <summary>
            Start the server
            </summary>
        </member>
        <member name="M:Inertia.Network.NetTcpServer.Close(Inertia.Network.NetworkDisconnectReason)">
            <summary>
            Close the server
            </summary>
            <param name="reason">Reason for closing the server</param>
        </member>
        <member name="M:Inertia.Network.NetTcpServer.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Network.NetUdpClient">
            <summary>
            Represent the UDP client
            </summary>
        </member>
        <member name="P:Inertia.Network.NetUdpClient.IsConnected">
            <summary>
            Return true if the client is connected
            </summary>
        </member>
        <member name="M:Inertia.Network.NetUdpClient.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Network.NetUdpClient"/>
            </summary>
            <param name="ip">Ip to use</param>
            <param name="port">Port to use</param>
        </member>
        <member name="M:Inertia.Network.NetUdpClient.Connect">
            <summary>
            Connect the client
            </summary>
        </member>
        <member name="M:Inertia.Network.NetUdpClient.Disconnect(Inertia.Network.NetworkDisconnectReason)">
            <summary>
            Disconnect the client
            </summary>
            <param name="reason">Reason for disconnection</param>
        </member>
        <member name="M:Inertia.Network.NetUdpClient.Send(System.Byte[])">
            <summary>
            Send the specified byte array to the server
            </summary>
            <param name="data">Byte array to send</param>
        </member>
        <member name="M:Inertia.Network.NetUdpClient.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Network.NetUdpServer">
            <summary>
            Represent the UDP server
            </summary>
        </member>
        <member name="E:Inertia.Network.NetUdpServer.ConnectionAdded">
            <summary>
            Occurs when receiving for the first time data from an udp connection
            </summary>
        </member>
        <member name="P:Inertia.Network.NetUdpServer.IsInitialized">
            <summary>
            Return true if <see cref="M:Inertia.Network.NetUdpServer.Start"/> was called successfully
            </summary>
        </member>
        <member name="M:Inertia.Network.NetUdpServer.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Network.NetUdpServer"/>
            </summary>
            <param name="ip">Ip to use</param>
            <param name="port">Port to use</param>
        </member>
        <member name="M:Inertia.Network.NetUdpServer.Start">
            <summary>
            Start the server
            </summary>
        </member>
        <member name="M:Inertia.Network.NetUdpServer.Close(Inertia.Network.NetworkDisconnectReason)">
            <summary>
            Close the server
            </summary>
            <param name="reason">Reason for closing the server</param>
        </member>
        <member name="M:Inertia.Network.NetUdpServer.SendTo(Inertia.Network.NetUdpConnection,System.Byte[])">
            <summary>
            Send byte array to the specified <see cref="T:Inertia.Network.NetUdpConnection"/>
            </summary>
            <param name="connection">Connection to sent data</param>
            <param name="data">Data to send</param>
        </member>
        <member name="M:Inertia.Network.NetUdpServer.SendTo(Inertia.Network.NetUdpConnection,Inertia.Network.NetworkMessage)">
            <summary>
            Send <see cref="T:Inertia.Network.NetworkMessage"/> instance to the specified <see cref="T:Inertia.Network.NetUdpConnection"/>
            </summary>
            <param name="connection">Connection to sent data</param>
            <param name="packet">Packet to send</param>
        </member>
        <member name="M:Inertia.Network.NetUdpServer.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Network.NetClient">
            <summary>
            Represent the base class for network client class
            </summary>
        </member>
        <member name="E:Inertia.Network.NetClient.Connected">
            <summary>
            Occurs when the client is connected
            </summary>
        </member>
        <member name="E:Inertia.Network.NetClient.Disconnected">
            <summary>
            Occurs when the client is disconnected
            </summary>
        </member>
        <member name="P:Inertia.Network.NetClient.IsDisposed">
            <summary>
            Return true if the current instance is disposed
            </summary>
        </member>
        <member name="M:Inertia.Network.NetClient.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Network.NetClient"/>
            </summary>
            <param name="ip">Ip to use</param>
            <param name="port">Port to use</param>
        </member>
        <member name="M:Inertia.Network.NetClient.Connect">
            <summary>
            Connect the client
            </summary>
        </member>
        <member name="M:Inertia.Network.NetClient.Disconnect(Inertia.Network.NetworkDisconnectReason)">
            <summary>
            Disconnect the client
            </summary>
            <param name="reason"></param>
        </member>
        <member name="M:Inertia.Network.NetClient.Send(System.Byte[])">
            <summary>
            Send the specified byte array to the server
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Inertia.Network.NetClient.ConnectAsync">
            <summary>
            Connect the client asynchronously
            </summary>
        </member>
        <member name="M:Inertia.Network.NetClient.Send(Inertia.Network.NetworkMessage)">
            <summary>
            Send the specified <see cref="T:Inertia.Network.NetworkMessage"/> to the server
            </summary>
            <param name="packet">Packet to send</param>
        </member>
        <member name="T:Inertia.Network.NetServer">
            <summary>
            Represent the base class for network server class
            </summary>
        </member>
        <member name="E:Inertia.Network.NetServer.Started">
            <summary>
            Occurs when the server is started
            </summary>
        </member>
        <member name="E:Inertia.Network.NetServer.Closed">
            <summary>
            Occurs when the server is closed
            </summary>
        </member>
        <member name="P:Inertia.Network.NetServer.IsDisposed">
            <summary>
            Return true if the current instance is disposed
            </summary>
        </member>
        <member name="M:Inertia.Network.NetServer.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Network.NetServer"/>
            </summary>
            <param name="ip">Ip to use</param>
            <param name="port">Port to use</param>
        </member>
        <member name="M:Inertia.Network.NetServer.Start">
            <summary>
            Start the server
            </summary>
        </member>
        <member name="M:Inertia.Network.NetServer.Close(Inertia.Network.NetworkDisconnectReason)">
            <summary>
            Close the server
            </summary>
            <param name="reason">Reason for closing the server</param>
        </member>
        <member name="M:Inertia.Network.NetServer.StartAsync">
            <summary>
            Start asynchronously the server
            </summary>
        </member>
        <member name="T:Inertia.Network.NetTcpConnection">
            <summary>
            Represents a TCP connection that is connected to a <see cref="T:Inertia.Network.NetTcpServer"/>
            </summary>
        </member>
        <member name="P:Inertia.Network.NetTcpConnection.IsDisposed">
            <summary>
            Return true if the current instance is disposed
            </summary>
        </member>
        <member name="P:Inertia.Network.NetTcpConnection.IsConnected">
            <summary>
            Return true if the current instance is connected
            </summary>
        </member>
        <member name="M:Inertia.Network.NetTcpConnection.Disconnect(Inertia.Network.NetworkDisconnectReason)">
            <summary>
            Disconnect the current instance
            </summary>
            <param name="reason">Reason for disconnection</param>
        </member>
        <member name="M:Inertia.Network.NetTcpConnection.Send(System.Byte[])">
            <summary>
            Send a byte array to the current TCP connection
            </summary>
            <param name="data">Data to send</param>
        </member>
        <member name="M:Inertia.Network.NetTcpConnection.Send(Inertia.Network.NetworkMessage)">
            <summary>
            Send a <see cref="T:Inertia.Network.NetworkMessage"/>instance to the current TCP connection
            </summary>
            <param name="packet">Packet to send</param>
        </member>
        <member name="M:Inertia.Network.NetTcpConnection.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Network.NetworkMessage">
            <summary>
            Custom network packet
            </summary>
        </member>
        <member name="P:Inertia.Network.NetworkMessage.Id">
            <summary>
            Get the id of the current packet
            </summary>
        </member>
        <member name="M:Inertia.Network.NetworkMessage.OnSerialize(Inertia.BasicWriter)">
            <summary>
            Serialize the current packet instance
            </summary>
            <param name="writer">The writer to use for serialization</param>
        </member>
        <member name="M:Inertia.Network.NetworkMessage.OnDeserialize(Inertia.BasicReader)">
            <summary>
            Deserialization method for the current packet instance
            </summary>
            <param name="reader">The reader to use for deserialization</param>
        </member>
        <member name="T:Inertia.Network.DefaultNetworkProtocol">
            <summary>
            Represent the main <see cref="T:Inertia.Network.NetworkProtocol"/> used for internal networking
            </summary>
        </member>
        <member name="P:Inertia.Network.DefaultNetworkProtocol.Instance">
            <summary>
            Get the instance of <see cref="T:Inertia.Network.DefaultNetworkProtocol"/> used
            </summary>
        </member>
        <member name="P:Inertia.Network.DefaultNetworkProtocol.MultiThreadedExecution">
            <summary>
            Set to True if you want the packets to be executed as multithreaded, otherwise False
            </summary>
        </member>
        <member name="F:Inertia.Network.DefaultNetworkProtocol.NetworkBufferLength">
            <summary>
            The network buffer length used for communications
            </summary>
        </member>
        <member name="P:Inertia.Network.DefaultNetworkProtocol.ProtocolVersion">
            <summary>
            Represent the protocol version used by the current protocol
            </summary>
        </member>
        <member name="M:Inertia.Network.DefaultNetworkProtocol.OnParseMessage(Inertia.Network.NetworkMessage)">
            <summary>
            Happens when parsing a <see cref="T:Inertia.Network.NetworkMessage"/> instance
            </summary>
            <param name="message">Packet to parse</param>
            <returns>Parsed packet to byte array</returns>
        </member>
        <member name="M:Inertia.Network.DefaultNetworkProtocol.OnReceiveData(Inertia.Network.NetTcpClient,Inertia.BasicReader)">
            <summary>
            Happens when receiving data from a <see cref="T:Inertia.Network.NetTcpClient"/>
            </summary>
            <param name="client">The connection that received the data</param>
            <param name="reader">The data in a <see cref="T:Inertia.BasicReader"/> instance</param>
        </member>
        <member name="M:Inertia.Network.DefaultNetworkProtocol.OnReceiveData(Inertia.Network.NetUdpClient,Inertia.BasicReader)">
            <summary>
            Happens when receiving data from a <see cref="T:Inertia.Network.NetUdpClient"/>
            </summary>
            <param name="client">The connection that received the data</param>
            <param name="reader">The data in a <see cref="T:Inertia.BasicReader"/> instance</param>
        </member>
        <member name="M:Inertia.Network.DefaultNetworkProtocol.OnReceiveData(Inertia.Network.NetTcpConnection,Inertia.BasicReader)">
            <summary>
            Happens when receiving data from a <see cref="T:Inertia.Network.NetTcpConnection"/>
            </summary>
            <param name="connection">The connection that received the data</param>
            <param name="reader">The data in a <see cref="T:Inertia.BasicReader"/> instance</param>
        </member>
        <member name="M:Inertia.Network.DefaultNetworkProtocol.OnReceiveData(Inertia.Network.NetUdpConnection,Inertia.BasicReader)">
            <summary>
            Happens when receiving data from a <see cref="T:Inertia.Network.NetUdpConnection"/>
            </summary>
            <param name="connection">The connection that received the data</param>
            <param name="reader">The data in a <see cref="T:Inertia.BasicReader"/> instance</param>
        </member>
        <member name="T:Inertia.Network.NetConnectionGroup">
            <summary>
            Allows sending data to multiple connections 
            </summary>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.#ctor">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Network.NetConnectionGroup"/>
            </summary>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.AddConnection(Inertia.Network.NetClient)">
            <summary>
            Add a <see cref="T:Inertia.Network.NetClient"/> to the group
            </summary>
            <param name="connection">Connection to add</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.AddConnection(Inertia.Network.NetTcpConnection)">
            <summary>
            Add a <see cref="T:Inertia.Network.NetTcpConnection"/> to the group
            </summary>
            <param name="connection">Connection to add</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.AddConnection(Inertia.Network.NetUdpConnection)">
            <summary>
            Add a <see cref="T:Inertia.Network.NetUdpConnection"/> to the group
            </summary>
            <param name="connection">Connection to add</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.RemoveConnection(Inertia.Network.NetClient)">
            <summary>
            Remove a <see cref="T:Inertia.Network.NetClient"/> from the group
            </summary>
            <param name="connection">Connection to remove</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.RemoveConnection(Inertia.Network.NetTcpConnection)">
            <summary>
            Remove a <see cref="T:Inertia.Network.NetTcpConnection"/> from the group
            </summary>
            <param name="connection">Connection to remove</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.RemoveConnection(Inertia.Network.NetUdpConnection)">
            <summary>
            Remove a <see cref="T:Inertia.Network.NetUdpConnection"/> from the group
            </summary>
            <param name="connection">Connection to remove</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.Send(Inertia.Network.NetworkMessage)">
            <summary>
            Send the specified <see cref="T:Inertia.Network.NetworkMessage"/> to the group
            </summary>
            <param name="packet">Packet instance to send</param>
        </member>
        <member name="M:Inertia.Network.NetConnectionGroup.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Network.NetUdpConnection">
            <summary>
            Represents a UDP connection that has already sent data to a <see cref="T:Inertia.Network.NetUdpServer"/>
            </summary>
        </member>
        <member name="P:Inertia.Network.NetUdpConnection.IsDisposed">
            <summary>
            Return true if the current instance is disposed
            </summary>
        </member>
        <member name="M:Inertia.Network.NetUdpConnection.Send(System.Byte[])">
            <summary>
            Send a byte array to the current UDP connection
            </summary>
            <param name="data">Data to send</param>
        </member>
        <member name="M:Inertia.Network.NetUdpConnection.Send(Inertia.Network.NetworkMessage)">
            <summary>
            Send a <see cref="T:Inertia.Network.NetworkMessage"/>instance to the current UDP connection
            </summary>
            <param name="packet">Packet to send</param>
        </member>
        <member name="M:Inertia.Network.NetUdpConnection.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Network.NetworkProtocol">
            <summary>
            Represents the class for writing and reading network data
            </summary>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.GetProtocol">
            <summary>
            Get the curent <see cref="T:Inertia.Network.NetworkProtocol"/> instance used
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.SetProtocol(Inertia.Network.NetworkProtocol)">
            <summary>
            Set a custom protocol instance to be used by the system
            </summary>
            <param name="protocol"><see cref="T:Inertia.Network.NetworkProtocol"/> instance to use</param>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.CreateInstance``1">
            <summary>
            Create an instance of the specified Type if it's an <see cref="T:Inertia.Network.NetworkMessage"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.CreateInstance(System.Type)">
            <summary>
            Create an instance of the specified Type if it's an <see cref="T:Inertia.Network.NetworkMessage"/>
            </summary>
            <param name="packetType"></param>
            <returns></returns>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.CreateInstance(System.UInt32)">
            <summary>
            Create an instance of a <see cref="T:Inertia.Network.NetworkMessage"/> based on his Id
            </summary>
            <param name="packetId">Id of the target <see cref="T:Inertia.Network.NetworkMessage"/></param>
            <returns></returns>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.GetHookerRefs(Inertia.Network.NetworkMessage)">
            <summary>
            Get a <see cref="T:Inertia.Network.NetworkMessageHookerRefs"/> if exist or null
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.CallHookerRef(Inertia.Network.NetworkMessage,Inertia.Network.NetTcpClient)">
            <summary>
            Invoke a MessageHooker with the specified parameters
            </summary>
            <param name="message"></param>
            <param name="client"></param>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.CallHookerRef(Inertia.Network.NetworkMessage,Inertia.Network.NetUdpClient)">
            <summary>
            Invoke a MessageHooker with the specified parameters
            </summary>
            <param name="message"></param>
            <param name="client"></param>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.CallHookerRef(Inertia.Network.NetworkMessage,Inertia.Network.NetTcpConnection)">
            <summary>
            Invoke a MessageHooker with the specified parameters
            </summary>
            <param name="message"></param>
            <param name="connection"></param>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.CallHookerRef(Inertia.Network.NetworkMessage,Inertia.Network.NetUdpConnection)">
            <summary>
            Invoke a MessageHooker with the specified parameters
            </summary>
            <param name="message"></param>
            <param name="connection"></param>
        </member>
        <member name="P:Inertia.Network.NetworkProtocol.ProtocolVersion">
            <summary>
            Represent the protocol version used by the current protocol
            </summary>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.OnParseMessage(Inertia.Network.NetworkMessage)">
            <summary>
            Happens when parsing a <see cref="T:Inertia.Network.NetworkMessage"/> instance
            </summary>
            <param name="packet">Packet to parse</param>
            <returns>Parsed packet to byte array</returns>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.OnReceiveData(Inertia.Network.NetTcpClient,Inertia.BasicReader)">
            <summary>
            Happens when receiving data from a <see cref="T:Inertia.Network.NetTcpClient"/>
            </summary>
            <param name="client">The connection that received the data</param>
            <param name="reader">The data in a <see cref="T:Inertia.BasicReader"/> instance</param>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.OnReceiveData(Inertia.Network.NetUdpClient,Inertia.BasicReader)">
            <summary>
            Happens when receiving data from a <see cref="T:Inertia.Network.NetUdpClient"/>
            </summary>
            <param name="client">The connection that received the data</param>
            <param name="reader">The data in a <see cref="T:Inertia.BasicReader"/> instance</param>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.OnReceiveData(Inertia.Network.NetTcpConnection,Inertia.BasicReader)">
            <summary>
            Happens when receiving data from a <see cref="T:Inertia.Network.NetTcpConnection"/>
            </summary>
            <param name="connection">The connection that received the data</param>
            <param name="reader">The data in a <see cref="T:Inertia.BasicReader"/> instance</param>
        </member>
        <member name="M:Inertia.Network.NetworkProtocol.OnReceiveData(Inertia.Network.NetUdpConnection,Inertia.BasicReader)">
            <summary>
            Happens when receiving data from a <see cref="T:Inertia.Network.NetUdpConnection"/>
            </summary>
            <param name="connection">The connection that received the data</param>
            <param name="reader">The data in a <see cref="T:Inertia.BasicReader"/> instance</param>
        </member>
        <member name="T:Inertia.Network.NetworkMessageHookerRefs">
            <summary>
            MessageHookers references
            </summary>
        </member>
        <member name="M:Inertia.Network.NetworkMessageHookerRefs.CallHookerRef(Inertia.Network.NetworkMessage,Inertia.Network.NetTcpClient)">
            <summary>
            Invoke a MessageHooker with the specified parameters
            </summary>
            <param name="message"></param>
            <param name="client"></param>
        </member>
        <member name="M:Inertia.Network.NetworkMessageHookerRefs.CallHookerRef(Inertia.Network.NetworkMessage,Inertia.Network.NetUdpClient)">
            <summary>
            Invoke a MessageHooker with the specified parameters
            </summary>
            <param name="message"></param>
            <param name="client"></param>
        </member>
        <member name="M:Inertia.Network.NetworkMessageHookerRefs.CallHookerRef(Inertia.Network.NetworkMessage,Inertia.Network.NetTcpConnection)">
            <summary>
            Invoke a MessageHooker with the specified parameters
            </summary>
            <param name="message"></param>
            <param name="connection"></param>
        </member>
        <member name="M:Inertia.Network.NetworkMessageHookerRefs.CallHookerRef(Inertia.Network.NetworkMessage,Inertia.Network.NetUdpConnection)">
            <summary>
            Invoke a MessageHooker with the specified parameters
            </summary>
            <param name="message"></param>
            <param name="connection"></param>
        </member>
        <member name="T:Inertia.Network.NetworkDisconnectReason">
            <summary>
            Enumerate all the disconnections reasons for the networking system
            </summary>
        </member>
        <member name="F:Inertia.Network.NetworkDisconnectReason.ManuallyDisconnect">
            <summary>
            Manual disconnection
            </summary>
        </member>
        <member name="F:Inertia.Network.NetworkDisconnectReason.ConnectionLost">
            <summary>
            Connection lost
            </summary>
        </member>
        <member name="F:Inertia.Network.NetworkDisconnectReason.ConnectionFailed">
            <summary>
            Connection failed
            </summary>
        </member>
        <member name="T:Inertia.Network.UnknownMessageException">
            <summary>
            Thrown when using a <see cref="T:System.Type"/> that isn't a subclass of <see cref="T:Inertia.Network.NetworkMessage"/>
            </summary>
        </member>
        <member name="P:Inertia.Network.UnknownMessageException.Message">
            <summary>
            Message of the exception
            </summary>
        </member>
        <member name="F:Inertia.Network.UnknownMessageException.PacketId">
            <summary>
            Unknown received MessageID
            </summary>
        </member>
        <member name="M:Inertia.Network.UnknownMessageException.#ctor(System.UInt32)">
            <summary>
            
            </summary>
            <param name="messageType"></param>
        </member>
        <member name="T:Inertia.Network.UserDatagramDataLengthLimitException">
            <summary>
            Thrown when sending more than <see cref="F:System.UInt16.MaxValue"/> bytes from UDP protocol
            </summary>
        </member>
        <member name="P:Inertia.Network.UserDatagramDataLengthLimitException.Message">
            <summary>
            Message of the exception
            </summary>
        </member>
        <member name="F:Inertia.Network.UserDatagramDataLengthLimitException.Length">
            <summary>
            Length of bytes trying to sent
            </summary>
        </member>
        <member name="M:Inertia.Network.UserDatagramDataLengthLimitException.#ctor(System.Int32)">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Network.UserDatagramDataLengthLimitException"/>
            </summary>
            <param name="length"></param>
        </member>
        <member name="T:Inertia.Realtime.Script">
            <summary>
            Execute realtime code
            </summary>
        </member>
        <member name="P:Inertia.Realtime.Script.DeltaTime">
            <summary>
            Returns the time elapsed since the last execution of the scripts. 
            </summary>
        </member>
        <member name="P:Inertia.Realtime.Script.Time">
            <summary>
            Returns the time elapsed from the process start time
            </summary>
        </member>
        <member name="F:Inertia.Realtime.Script.MaxExecutionPerSecond">
            <summary>
            Get or set the maximum execution per second for scripting system
            </summary>
        </member>
        <member name="P:Inertia.Realtime.Script.IsDestroyed">
            <summary>
            Return true is the current instance is destroyed
            </summary>
        </member>
        <member name="M:Inertia.Realtime.Script.OnAwake(Inertia.Realtime.ScriptArgumentsCollection)">
            <summary>
            Occurs when the script initializes
            </summary>
            <param name="args">The arguments passed to the script initialization</param>
        </member>
        <member name="M:Inertia.Realtime.Script.OnUpdate">
            <summary>
            Occurs when the script is updated (each frame)
            </summary>
        </member>
        <member name="M:Inertia.Realtime.Script.OnDestroy">
            <summary>
            Occurs before the script is destroyed
            </summary>
        </member>
        <member name="M:Inertia.Realtime.Script.Destroy">
            <summary>
            Destroy the current instance of the script
            </summary>
        </member>
        <member name="M:Inertia.Realtime.Script.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Realtime.ScriptArgumentsCollection">
            <summary>
            Represent the arguments collection associated to a script in the initialization
            </summary>
        </member>
        <member name="P:Inertia.Realtime.ScriptArgumentsCollection.IsDisposed">
            <summary>
            Return true if the current instance is disposed
            </summary>
        </member>
        <member name="P:Inertia.Realtime.ScriptArgumentsCollection.Count">
            <summary>
            Return the number of arguments in the collection
            </summary>
        </member>
        <member name="F:Inertia.Realtime.ScriptArgumentsCollection.Position">
            <summary>
            Return the next argument position in the collection
            </summary>
        </member>
        <member name="P:Inertia.Realtime.ScriptArgumentsCollection.Item(System.Int32)">
            <summary>
            Return the argument as object at the specified index in the collection
            </summary>
            <param name="index">Target index</param>
            <returns>Argument as object</returns>
        </member>
        <member name="M:Inertia.Realtime.ScriptArgumentsCollection.GetArgumentAt``1(System.Int32)">
            <summary>
            Return the argument as <typeparamref name="T"/> at the specified index in the collection
            </summary>
            <typeparam name="T">Specified <see cref="T:System.Type"/> to cast</typeparam>
            <param name="index">Target index</param>
            <returns>Argument as <typeparamref name="T"/></returns>
        </member>
        <member name="M:Inertia.Realtime.ScriptArgumentsCollection.GetNextArgument``1">
            <summary>
            Return the next argument based on <see cref="F:Inertia.Realtime.ScriptArgumentsCollection.Position"/> field casted to <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Target <see cref="T:System.Type"/> of the argument</typeparam>
            <returns>Argument as <typeparamref name="T"/></returns>
        </member>
        <member name="M:Inertia.Realtime.ScriptArgumentsCollection.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Realtime.ScriptCollection">
            <summary>
            Allows creation and management of scripts running in real time
            </summary>
        </member>
        <member name="P:Inertia.Realtime.ScriptCollection.Count">
            <summary>
            Return the number of <see cref="T:Inertia.Realtime.Script"/> running in the collection
            </summary>
        </member>
        <member name="M:Inertia.Realtime.ScriptCollection.#ctor">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.Realtime.ScriptCollection"/>
            </summary>
        </member>
        <member name="M:Inertia.Realtime.ScriptCollection.Add``1(System.Object[])">
            <summary>
            Create a new instance of <typeparamref name="T"/> with the specified arguments
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the target <see cref="T:Inertia.Realtime.Script"/></typeparam>
            <param name="args">The arguments to be passed on the initialization</param>
            <returns>Return the created instance of <typeparamref name="T"/></returns>
        </member>
        <member name="M:Inertia.Realtime.ScriptCollection.Remove``1">
            <summary>
            Remove the first occurence of type <typeparamref name="T"/> in the collection
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of <see cref="T:Inertia.Realtime.Script"/> to remove</typeparam>
        </member>
        <member name="M:Inertia.Realtime.ScriptCollection.RemoveAll``1">
            <summary>
            Remove all <see cref="T:Inertia.Realtime.Script"/> of type <typeparamref name="T"/> running in the collection
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of <see cref="T:Inertia.Realtime.Script"/> to remove</typeparam>
        </member>
        <member name="M:Inertia.Realtime.ScriptCollection.GetScript``1">
            <summary>
            Get the first occurence of the specified <see cref="T:Inertia.Realtime.Script"/> of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The target <see cref="T:Inertia.Realtime.Script"/> to get</typeparam>
            <returns>The first occurence of <typeparamref name="T"/> running in the collection</returns>
        </member>
        <member name="M:Inertia.Realtime.ScriptCollection.GetScripts``1">
            <summary>
            Get all scripts of type <typeparamref name="T"/> in the collection
            </summary>
            <typeparam name="T">The target <see cref="T:Inertia.Realtime.Script"/> to get</typeparam>
            <returns>All <typeparamref name="T"/> script running in the collection</returns>
        </member>
        <member name="M:Inertia.Realtime.ScriptCollection.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Realtime.ScriptInTime">
            <summary>
            Represent a class that offers scripting execution in specified time
            </summary>
        </member>
        <member name="P:Inertia.Realtime.ScriptInTime.Permanent">
            <summary>
            Return true if the current <see cref="T:Inertia.Realtime.ScriptInTime"/> run permanently
            </summary>
        </member>
        <member name="M:Inertia.Realtime.ScriptInTime.#ctor(System.Single,BasicAction,System.Boolean)">
            <summary>
            Instantiate a new instance of the class <see cref="T:Inertia.Realtime.ScriptInTime"/>
            </summary>
            <param name="time">Time between each execution</param>
            <param name="action">Action to execute</param>
            <param name="permanent">True if permanent execution</param>
        </member>
        <member name="T:Inertia.FlexDictionary`1">
            <summary>
            Represents a collection of keys associated with values that can be of any type
            </summary>
            <typeparam name="TKey">The type of object used for dictionary keys</typeparam>
        </member>
        <member name="P:Inertia.FlexDictionary`1.Count">
            <summary>
            Returns the number of values that are stored in the dictionnary.
            </summary>
        </member>
        <member name="M:Inertia.FlexDictionary`1.#ctor">
            <summary>
            Create a new instance of a <see cref="T:Inertia.FlexDictionary`1"/> class
            </summary>
        </member>
        <member name="P:Inertia.FlexDictionary`1.Item(`0)">
            <summary>
            Retrieves the object stored in the dictionary with to the provided key
            </summary>
            <param name="key">The key associated to the target object</param>
            <returns>The object associated to the specified <paramref name="key"/> or null</returns>
        </member>
        <member name="M:Inertia.FlexDictionary`1.GetKeys">
            <summary>
            Retrieves all the keys from the dictionnary
            </summary>
            <returns>An array of <typeparamref name="TKey"/> stored in the dictionnary</returns>
        </member>
        <member name="M:Inertia.FlexDictionary`1.Add``1(`0,``0)">
            <summary>
            Add a new object associated to the specified key to the dictionnary
            </summary>
            <typeparam name="TData">Type of the object that will be added</typeparam>
            <param name="identifier">The key associated</param>
            <param name="data">The object to add</param>
            <returns>The current <see cref="T:Inertia.FlexDictionary`1"/> instance</returns>
        </member>
        <member name="M:Inertia.FlexDictionary`1.Remove(`0)">
            <summary>
            Remove the object from the dictionnary associated to the specified key
            </summary>
            <param name="identifier">The key to remove</param>
            <returns>The current <see cref="T:Inertia.FlexDictionary`1"/> instance</returns>
        </member>
        <member name="M:Inertia.FlexDictionary`1.Replace``1(`0,``0)">
            <summary>
            Replace a stored object (nothing happend if the specified key don't exist)
            </summary>
            <typeparam name="TData">The type of the object to add</typeparam>
            <param name="identifier">The key that already exist</param>
            <param name="value">The new object</param>
            <returns>The current <see cref="T:Inertia.FlexDictionary`1"/> instance</returns>
        </member>
        <member name="M:Inertia.FlexDictionary`1.TryGetValue``1(`0,``0@)">
            <summary>
            Try to retrieve a stored object with the specified key
            </summary>
            <typeparam name="TData">The type of the object to get</typeparam>
            <param name="identifier">The key associated</param>
            <param name="value">The variable that will store the object</param>
            <returns>Return true if the object was found and referenced to <paramref name="value"/> or false if not</returns>
            <remarks>If the object wasn't found, the result will be the default value of <typeparamref name="TData"/></remarks>
        </member>
        <member name="M:Inertia.FlexDictionary`1.GetValue``1(`0)">
            <summary>
            Retrieve a stored object and return it
            </summary>
            <typeparam name="TData">The type of the target object</typeparam>
            <param name="identifier">The key associated to the target object</param>
            <returns>The target object that is stored</returns>
            <exception cref="T:System.NullReferenceException">Thrown if the specified key don't exist</exception>
        </member>
        <member name="M:Inertia.FlexDictionary`1.GetValues(`0[])">
            <summary>
            Retrieve a list of object without type and return them
            </summary>
            <param name="identifiers">An array of key associated to the target objects</param>
            <returns>An array of objects that are stored</returns>
            <remarks>If a key don't exist in the dictionnary, the object in the returned array will be null</remarks>
        </member>
        <member name="M:Inertia.FlexDictionary`1.GetValues``1(`0[])">
            <summary>
            Retrieve a list of object with type and return them
            </summary>
            <typeparam name="TData">The target type for the objects</typeparam>
            <param name="identifiers">An array of key associated to the target objects</param>
            <returns>An array of objects of type <typeparamref name="TData"/></returns>
            <remarks>If an object wasn't found, the result will be the default value of <typeparamref name="TData"/></remarks>
        </member>
        <member name="M:Inertia.FlexDictionary`1.Exist(`0)">
            <summary>
            Check if a key exist in the dictionnary
            </summary>
            <param name="identifier">The target key to find</param>
            <returns>Return true if the specified key exist in the dictionnary, or false if not</returns>
        </member>
        <member name="M:Inertia.FlexDictionary`1.Clear">
            <summary>
            Clear the data stored in the current instance
            </summary>
        </member>
        <member name="M:Inertia.FlexDictionary`1.Dispose">
            <summary>
            Dispose all the resources used by the <see cref="T:Inertia.FlexDictionary`1"/> instance
            </summary>
        </member>
        <member name="T:Inertia.InertiaIO">
            <summary>
            Class containing methods for managing and transforming data
            </summary>
        </member>
        <member name="M:Inertia.InertiaIO.GetFilesPathFromDirectory(System.String,System.Boolean)">
            <summary>
            Returns all file paths of the files contained in the specified folder
            </summary>
            <param name="path">The target folder path</param>
            <param name="inheritance">True if sub folders has to be included</param>
            <returns>String array representing all paths</returns>
        </member>
        <member name="M:Inertia.InertiaIO.OpenInExplorer(System.String)">
            <summary>
            Open the target folder path in the file explorer
            </summary>
            <param name="path">Target folder to open</param>
        </member>
        <member name="M:Inertia.InertiaIO.AppendAllBytes(System.String,System.Byte[])">
            <summary>
            Add the specified byte array to the end of the target file path
            </summary>
            <param name="path">Path of the target file</param>
            <param name="data">The byte array to add</param>
        </member>
        <member name="M:Inertia.InertiaIO.GetSHA256(System.Byte[])">
            <summary>
            Get the SHA256 key representation of the specified byte array data
            </summary>
            <param name="data">Target byte array data</param>
            <returns>The SHA256 representation</returns>
        </member>
        <member name="M:Inertia.InertiaIO.GetSHA256(System.IO.FileStream)">
            <summary>
            Get the SHA256 key representation of the specified <see cref="T:System.IO.FileStream"/>
            </summary>
            <param name="stream">Target <see cref="T:System.IO.FileStream"/></param>
            <returns>The SHA256 representation</returns>
        </member>
        <member name="M:Inertia.InertiaIO.Compress(System.Byte[],System.Boolean@)">
            <summary>
            Compress the specified byte array and return the compressed one
            </summary>
            <param name="data">Target byte array to compress</param>
            <param name="compressed">Return true if the returned data is lower in length than the non-compressed data</param>
            <returns>Compressed byte array</returns>
        </member>
        <member name="M:Inertia.InertiaIO.Decompress(System.Byte[])">
            <summary>
            Decompress the specified byte array and return the decompressed one
            </summary>
            <param name="compressedData">Target byte array to decompress</param>
            <returns>Decompressed byte array</returns>
        </member>
        <member name="M:Inertia.InertiaIO.EncryptWithString(System.Byte[],System.String)">
            <summary>
            Encrypt the target byte array with the specified string key
            </summary>
            <param name="data">Target byte array to encrypt</param>
            <param name="key">Target string key for encryption</param>
            <returns>Encrypted byte array</returns>
        </member>
        <member name="M:Inertia.InertiaIO.DecryptWithString(System.Byte[],System.String)">
            <summary>
            Encrypt the target byte array with the specified string key
            </summary>
            <param name="encryptedData">Target byte array to encrypt</param>
            <param name="key">Target string key for encryption</param>
            <returns>Decrypted byte array</returns>
        </member>
        <member name="T:Inertia.BasicReader">
            <summary>
            Provides read-only data management
            </summary>
        </member>
        <member name="P:Inertia.BasicReader.IsDisposed">
            <summary>
            Return true is the current instance is disposed
            </summary>
        </member>
        <member name="P:Inertia.BasicReader.TotalLength">
            <summary>
            Get the total length currently in the stream
            </summary>
        </member>
        <member name="P:Inertia.BasicReader.UnreadedLength">
            <summary>
            Get the total length unreaded (based on current position in the stream)
            </summary>
        </member>
        <member name="P:Inertia.BasicReader.Position">
            <summary>
            Get or set the current position in the stream
            </summary>
        </member>
        <member name="M:Inertia.BasicReader.#ctor">
            <summary>
            Create a new instance with empty data
            </summary>
        </member>
        <member name="M:Inertia.BasicReader.#ctor(System.Text.Encoding)">
            <summary>
            Create a new instance with empty data based on the specified <see cref="T:System.Text.Encoding"/>
            </summary>
            <param name="encoding">Target <see cref="T:System.Text.Encoding"/> for the reader</param>
        </member>
        <member name="M:Inertia.BasicReader.#ctor(System.Byte[])">
            <summary>
            Create a new instance with the specified byte array data
            </summary>
            <param name="data">The target byte array</param>
        </member>
        <member name="M:Inertia.BasicReader.#ctor(System.Byte[],System.Text.Encoding)">
            <summary>
            Create a new instance with the specified byte array data based on the specified <see cref="T:System.Text.Encoding"/>
            </summary>
            <param name="data">The target byte array</param>
            <param name="encoding">Target <see cref="T:System.Text.Encoding"/> for the reader</param>
        </member>
        <member name="M:Inertia.BasicReader.Clear">
            <summary>
            Clear the current instance and create a new empty stream
            </summary>
        </member>
        <member name="M:Inertia.BasicReader.Fill(System.Byte[])">
            <summary>
            Fill the current stream with the specified byte array data (added at the end)
            </summary>
            <param name="data">Target byte array data to add</param>
            <returns></returns>
        </member>
        <member name="M:Inertia.BasicReader.Fill(System.Byte[],System.Int64)">
            <summary>
            Fill the current stream with the specified byte array data (added at the end)
            </summary>
            <param name="data">Target byte array data to add</param>
            <param name="startIndex">Start index</param>
            <returns></returns>
        </member>
        <member name="M:Inertia.BasicReader.RemoveReadedBytes">
            <summary>
            Remove all the readed bytes in the stream (before the current position) and refresh the stream with the non-readed bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inertia.BasicReader.GetBool">
            <summary>
            Read a <see cref="T:System.Boolean"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Boolean"/> value (or false if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetBoolFlag(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Inertia.BasicReader.GetString">
            <summary>
            Read a <see cref="T:System.String"/> value with the current instance <see cref="T:System.Text.Encoding"/> algorithm in the stream and change the position
            </summary>
            <returns>Readed string value (or <see cref="F:System.String.Empty"/> if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetByte">
            <summary>
            Read a <see cref="T:System.Byte"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Byte"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetSByte">
            <summary>
            Read a <see cref="T:System.SByte"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.SByte"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetChar">
            <summary>
            Read a <see cref="T:System.Char"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Char"/> value (or (char)0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetShort">
            <summary>
            Read a <see cref="T:System.Int16"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Int16"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetUShort">
            <summary>
            Read a <see cref="T:System.UInt16"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.UInt16"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetFloat">
            <summary>
            Read a <see cref="T:System.Single"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Single"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetDouble">
            <summary>
            Read a <see cref="T:System.Double"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Double"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetDecimal">
            <summary>
            Read a <see cref="T:System.Decimal"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Decimal"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetInt">
            <summary>
            Read a <see cref="T:System.Int32"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Int32"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetUInt">
            <summary>
            Read a <see cref="T:System.UInt32"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.UInt32"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetLong">
            <summary>
            Read a <see cref="T:System.Int64"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Int64"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetULong">
            <summary>
            Read a <see cref="T:System.UInt64"/> value in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.UInt64"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetBytes">
            <summary>
            Read a byte array (with an <see cref="T:System.Int32"/> length header) in the stream and change the position
            </summary>
            <returns>Readed <see cref="T:System.Int16"/> value (or 0 if nothing can be read)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetBytes(System.Int64)">
            <summary>
            Read specified number of <see cref="T:System.Byte"/> in the stream and change the position
            </summary>
            <param name="length">Length ot the byte array result</param>
            <returns>Complete byte array of specified length (or an empty byte array if the <see cref="P:Inertia.BasicReader.UnreadedLength"/> is too small)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetDateTime">
            <summary>
            Read DateTime in the stream and change the position
            </summary>
            <returns>Return a DateTime instance</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetObject``1">
            <summary>
            Read the specified <typeparamref name="T"/> in the stream (only if the type has a <see cref="T:System.SerializableAttribute"/>)
            </summary>
            <typeparam name="T">Target type to deserialize</typeparam>
            <returns>An deserialized instance of the specified Type</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetObject">
            <summary>
            Read the next object in the stream (only if the type has a <see cref="T:System.SerializableAttribute"/>)
            </summary>
            <returns>An deserialized object</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetValue(System.Type)">
            <summary>
            Read the specified <see cref="T:System.Type"/> and return it (if it's readable, or null)
            </summary>
            <param name="valueType">The type of the target object</param>
            <returns>Return the readed value (or null)</returns>
        </member>
        <member name="M:Inertia.BasicReader.GetValues(System.Type[])">
            <summary>
            Read all object corresponding to the specified <see cref="T:System.Type"/> in the array (null if unreadable)
            </summary>
            <param name="valuesType">Array of <see cref="T:System.Type"/> to read</param>
            <returns><see cref="T:System.Collections.IList"/> of all objects readed (can contains null elements)</returns>
        </member>
        <member name="M:Inertia.BasicReader.Dispose">
            <summary>
            Dispose the reader (can't be used anymore)
            </summary>
        </member>
        <member name="T:Inertia.BasicWriter">
            <summary>
            Provides methods for writing data
            </summary>
        </member>
        <member name="P:Inertia.BasicWriter.IsDisposed">
            <summary>
            Return true is the current instance is disposed
            </summary>
        </member>
        <member name="P:Inertia.BasicWriter.TotalLength">
            <summary>
            Get the total length currently in the stream
            </summary>
        </member>
        <member name="P:Inertia.BasicWriter.Position">
            <summary>
            Get or set the current position in the stream
            </summary>
        </member>
        <member name="M:Inertia.BasicWriter.#ctor">
            <summary>
            Create a new instance based on <see cref="P:System.Text.Encoding.UTF8"/> algorithm
            </summary>
        </member>
        <member name="M:Inertia.BasicWriter.#ctor(System.Text.Encoding)">
            <summary>
            Create a new instance based on the specified <see cref="T:System.Text.Encoding"/> algorithm
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="M:Inertia.BasicWriter.Clear">
            <summary>
            Clear the current instance and create a new empty stream
            </summary>
        </member>
        <member name="M:Inertia.BasicWriter.SetEmpty(System.UInt32)">
            <summary>
            Write an empty (0) byte array without header of specified size
            </summary>
            <param name="size">Target byte array size</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetBool(System.Boolean)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetBoolFlag(System.Boolean[])">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetString(System.String)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetFloat(System.Single)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetDecimal(System.Decimal)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetDouble(System.Double)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetByte(System.Byte)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetSByte(System.SByte)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetChar(System.Char)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetShort(System.Int16)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetUShort(System.UInt16)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetInt(System.Int32)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetUInt(System.UInt32)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetLong(System.Int64)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetULong(System.UInt64)">
            <summary>
            Write the specified value in the stream
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetBytes(System.Byte[])">
            <summary>
            Write the specified value in the stream (with size)
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetBytesWithoutHeader(System.Byte[])">
            <summary>
            Write the specified value in the stream (without size)
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetDateTime(System.DateTime)">
            <summary>
            Write the specified value in the stream (without size)
            </summary>
            <param name="value">Target value to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetObject``1(``0)">
            <summary>
            Write the specified serializable value in the stream
            </summary>
            <typeparam name="T">The type of object to serialize</typeparam>
            <param name="value">The object to serialize</param>
            <returns></returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetValue(System.Object)">
            <summary>
            Automatically write the specified value in the stream (if serializable)
            </summary>
            <param name="value">Serializable value</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.SetValues(System.Object[])">
            <summary>
            Automatically write the specified values in the stream (if serializable)
            </summary>
            <param name="values">All serializable values to write</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.BasicWriter.ToArray">
            <summary>
            Export all writed data as byte array
            </summary>
            <returns>A byte array representing the data written</returns>
        </member>
        <member name="M:Inertia.BasicWriter.ToArrayAndClear">
            <summary>
            Export all writed data as byte array and clear the current instance
            </summary>
            <returns>A byte array representing the data written</returns>
        </member>
        <member name="M:Inertia.BasicWriter.ToArrayAndDispose">
            <summary>
            Export all writed data as byte array and dispose the current instance
            </summary>
            <returns>A byte array representing the data written</returns>
        </member>
        <member name="M:Inertia.BasicWriter.Dispose">
            <summary>
            Dispose the reader (can't be used anymore)
            </summary>
        </member>
        <member name="T:Inertia.CommandHooker">
            <summary>
            Represent the class that will manage the command reception and execution
            </summary>
        </member>
        <member name="M:Inertia.CommandHooker.GetAllCommands">
            <summary>
            Return all existing <see cref="T:Inertia.TextCommand"/> instancied
            </summary>
            <returns>An array of <see cref="T:Inertia.TextCommand"/> representing the existing <see cref="T:Inertia.TextCommand"/></returns>
        </member>
        <member name="M:Inertia.CommandHooker.GetCommandByName(System.String)">
            <summary>
            Return the <see cref="T:Inertia.TextCommand"/> associated to the specified name 
            </summary>
            <param name="commandName">The name of the command</param>
            <returns>The <see cref="T:Inertia.TextCommand"/> associated or null if none</returns>
        </member>
        <member name="M:Inertia.CommandHooker.ExecuteTextCommand(System.String,System.Object[])">
            <summary>
            Parse a string command line to a <see cref="T:Inertia.TextCommand"/> and execute it with facultative data
            </summary>
            <param name="commandLine">The string line to parse</param>
            <param name="dataCollection">Facultative data objects</param>
            <returns>Return true if the command was executed</returns>
        </member>
        <member name="M:Inertia.CommandHooker.ExecuteCommandByName(System.String,System.Object[],System.String[])">
            <summary>
            Get the associated <see cref="T:Inertia.TextCommand"/> based on the name and execute it with the specified arguments
            </summary>
            <param name="commandName">The command anme</param>
            <param name="dataCollection">Facultative data objects</param>
            <param name="arguments">Facultative string arguments</param>
            <returns></returns>
        </member>
        <member name="T:Inertia.TextCommandArgs">
            <summary>
            Represent the class manager for the <see cref="T:Inertia.TextCommand"/>'s arguments
            </summary>
        </member>
        <member name="P:Inertia.TextCommandArgs.Name">
            <summary>
            Get the name of the executed <see cref="T:Inertia.TextCommand"/>
            </summary>
        </member>
        <member name="P:Inertia.TextCommandArgs.Count">
            <summary>
            Return the number of string arguments in the command
            </summary>
        </member>
        <member name="P:Inertia.TextCommandArgs.DataCount">
            <summary>
            Return the number of data objects arguments in the command
            </summary>
        </member>
        <member name="P:Inertia.TextCommandArgs.Position">
            <summary>
            Return the position of the last selected string argument
            </summary>
        </member>
        <member name="P:Inertia.TextCommandArgs.Item(System.Int32)">
            <summary>
            Return the string argument at the specified index
            </summary>
            <param name="index">The index to find the argument</param>
            <returns>Return the string argument</returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.GetDataAt(System.Int32)">
            <summary>
            Return the data object at the specified argument
            </summary>
            <param name="index">The index to find the argument</param>
            <returns>Return the data object casted to <see cref="T:System.Object"/></returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.GetDataAt``1(System.Int32)">
            <summary>
            Return the data object at the specified argument
            </summary>
            <typeparam name="T">The target data object type</typeparam>
            <param name="index">The index to find the argument</param>
            <returns>Return the data object casted to <typeparamref name="T"/></returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.GetNextArgument(System.String@)">
            <summary>
            Get the next string argument based on the <see cref="P:Inertia.TextCommandArgs.Position"/>
            </summary>
            <param name="argument">The string argument result</param>
            <returns>Return false if no string argument is available at the target position</returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.GetCollection">
            <summary>
            Get all the string arguments in the command
            </summary>
            <returns>Return an array of string representing the string arguments</returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.GetDataCollection">
            <summary>
            Get all the data objects arguments in the command
            </summary>
            <returns>Return an array of object representing the data objects arguments</returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.CombineArguments(System.Int32)">
            <summary>
            Combine all arguments to a string starting at the specified index
            </summary>
            <param name="startIndex">Index where to start</param>
            <returns></returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.CombineArguments(System.Int32,System.Int32)">
            <summary>
            Combine all arguments to a string starting at the specified index
            </summary>
            <param name="startIndex">Index where to start</param>
            <param name="length">Number of arguments to include</param>
            <returns></returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.CombineAllArguments">
            <summary>
            Combine all arguments to a string from the start to the end
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.ResetArg(System.Int32,System.String)">
            <summary>
            Reset the value of the argument at the specified index
            </summary>
            <param name="index">Index of the argument</param>
            <param name="value">New value of the argument</param>
        </member>
        <member name="M:Inertia.TextCommandArgs.ToString">
            <summary>
            Get the base command line
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inertia.TextCommandArgs.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.TextCommand">
            <summary>
            Represent the parent heritage of all textual commands
            </summary>
        </member>
        <member name="P:Inertia.TextCommand.Name">
            <summary>
            Return the command's name
            </summary>
        </member>
        <member name="M:Inertia.TextCommand.Execute(Inertia.TextCommandArgs)">
            <summary>
            The method executed when this command is called
            </summary>
            <param name="args">The attached command's arguments</param>
        </member>
        <member name="T:Inertia.Clock">
            <summary>
            Offers the possibility to obtain the time elapsed between a block of code.
            </summary>
        </member>
        <member name="M:Inertia.Clock.GetElapsedMilliseconds(BasicAction)">
            <summary>
            Automatically creates an instance of the class Clock and returns in milliseconds the execution time of the indicated code then dispose the instance
            </summary>
            <param name="handler">The code to execute</param>
            <returns>Time elapsed in milliseconds</returns>
        </member>
        <member name="M:Inertia.Clock.GetElapsedSeconds(BasicAction)">
            <summary>
            Automatically creates an instance of the class Clock and returns in seconds the execution time of the indicated code then dispose the instance
            </summary>
            <param name="handler">The code to execute</param>
            <returns>Time elapsed in seconds</returns>
        </member>
        <member name="M:Inertia.Clock.#ctor">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.Clock"/>
            </summary>
        </member>
        <member name="M:Inertia.Clock.Reset">
            <summary>
            Reset the start time of the clock
            </summary>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.Clock.GetElapsedMilliseconds">
            <summary>
            Returns in milliseconds the execution time between the last reset
            </summary>
            <returns>Time elapsed in milliseconds</returns>
        </member>
        <member name="M:Inertia.Clock.GetElapsedMillisecondsAndReset">
            <summary>
            Returns in milliseconds the execution time between the last reset and then reset the clock
            </summary>
            <returns>Time elapsed in milliseconds</returns>
        </member>
        <member name="M:Inertia.Clock.GetElapsedSeconds">
            <summary>
            Returns in seconds the execution time between the last reset
            </summary>
            <returns>Time elapsed in seconds</returns>
        </member>
        <member name="M:Inertia.Clock.GetElapsedSecondsAndReset">
            <summary>
            Returns in seconds the execution time between the last reset and then reset the clock
            </summary>
            <returns>Time elapsed in seconds</returns>
        </member>
        <member name="M:Inertia.Clock.Dispose">
            <summary>
            Dispose the current instance of the class
            </summary>
        </member>
        <member name="T:Inertia.AutoQueueExecutor">
            <summary>
            Queue actions and execute them automatically
            </summary>
        </member>
        <member name="P:Inertia.AutoQueueExecutor.IsDisposed">
            <summary>
            Return true if <see cref="M:Inertia.AutoQueueExecutor.Dispose"/> was called
            </summary>
        </member>
        <member name="P:Inertia.AutoQueueExecutor.Count">
            <summary>
            Return the number of actions currently queued
            </summary>
        </member>
        <member name="M:Inertia.AutoQueueExecutor.#ctor">
            <summary>
            Create a new instance
            </summary>
        </member>
        <member name="M:Inertia.AutoQueueExecutor.Enqueue(BasicAction[])">
            <summary>
            Enqueue the specified actions at the end of the queue
            </summary>
            <param name="handlers">Actions to enqueue</param>
        </member>
        <member name="M:Inertia.AutoQueueExecutor.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.ManualQueueExecutor">
            <summary>
            Queue actions and execute them manually
            </summary>
        </member>
        <member name="P:Inertia.ManualQueueExecutor.IsDisposed">
            <summary>
            Return true if <see cref="M:Inertia.ManualQueueExecutor.Dispose"/> was called
            </summary>
        </member>
        <member name="P:Inertia.ManualQueueExecutor.Count">
            <summary>
            Return the number of actions currently queued
            </summary>
        </member>
        <member name="M:Inertia.ManualQueueExecutor.#ctor">
            <summary>
            Create a new instance
            </summary>
        </member>
        <member name="M:Inertia.ManualQueueExecutor.Enqueue(BasicAction[])">
            <summary>
            Enqueue the specified actions at the end of the queue
            </summary>
            <param name="actions">Actions to enqueue</param>
            <returns>Return the current instance</returns>
        </member>
        <member name="M:Inertia.ManualQueueExecutor.Execute">
            <summary>
            Execute all the actions queued and remove them from the queue
            </summary>
        </member>
        <member name="M:Inertia.ManualQueueExecutor.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Storage.DataStorage`1">
            <summary>
            Represents the class for storing and managing datas using <see cref="T:Inertia.FlexDictionary`1"/>
            </summary>
            <typeparam name="KeyType">Target key <see cref="T:System.Type"/></typeparam>
        </member>
        <member name="E:Inertia.Storage.DataStorage`1.Saved">
            <summary>
            Occurs when the current instance is saved by <see cref="M:Inertia.Storage.DataStorage`1.SaveAsync(System.String,System.String)"/>
            </summary>
        </member>
        <member name="E:Inertia.Storage.DataStorage`1.Loaded">
            <summary>
            Occurs when the current instance is loaded by <see cref="M:Inertia.Storage.DataStorage`1.LoadAsync(System.String)"/>
            </summary>
        </member>
        <member name="E:Inertia.Storage.DataStorage`1.SaveProgress">
            <summary>
            Occurs when the save procedure progress
            </summary>
        </member>
        <member name="E:Inertia.Storage.DataStorage`1.LoadProgress">
            <summary>
            Occurs when the load procedure progress
            </summary>
        </member>
        <member name="E:Inertia.Storage.DataStorage`1.SaveFailed">
            <summary>
            Occurs when the save procedure failed
            </summary>
        </member>
        <member name="E:Inertia.Storage.DataStorage`1.LoadFailed">
            <summary>
            Occurs when the load procedure failed
            </summary>
        </member>
        <member name="P:Inertia.Storage.DataStorage`1.Password">
            <summary>
            Get or set the password that will be used for the current instance
            </summary>
        </member>
        <member name="P:Inertia.Storage.DataStorage`1.AutoCompression">
            <summary>
            
            </summary>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.#ctor(System.Boolean)">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.Storage.DataStorage`1"/>
            </summary>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.#ctor(System.String,System.Boolean)">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.Storage.DataStorage`1"/>
            </summary>
            <param name="password">The password to use in the current instance</param>
            <param name="autoCompression"></param>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.Save(System.String,System.String)">
            <summary>
            Save the current storage to the specified folder path using the specified file name
            </summary>
            <param name="folderPath">Folder path where to save the file</param>
            <param name="fileName">Target file name</param>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.SaveAsync(System.String,System.String)">
            <summary>
            Save asynchronously the current storage to the specified folder path using the specified file name
            </summary>
            <param name="folderPath">Folder path where to save the file</param>
            <param name="fileName">Target file name</param>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.Load(System.String)">
            <summary>
            Load the target file in the current storage
            </summary>
            <param name="filePath">File path to load</param>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.Load(System.Byte[])">
            <summary>
            Load the target data in the current storage
            </summary>
            <param name="data">Data to load</param>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.LoadAsync(System.String)">
            <summary>
            Load asynchronously the target file in the current storage
            </summary>
            <param name="filePath">File path to load</param>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.LoadAsync(System.Byte[])">
            <summary>
            Load asynchronously the target data in the current storage
            </summary>
            <param name="data">Data to load</param>
        </member>
        <member name="M:Inertia.Storage.DataStorage`1.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Storage.FileStorage">
            <summary>
            Represents the class for storing and managing files
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.Saved">
            <summary>
            Occurs when the current instance is saved by <see cref="M:Inertia.Storage.FileStorage.SaveAsync(System.String,System.String)"/>
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.Loaded">
            <summary>
            Occurs when the current instance is loaded by <see cref="M:Inertia.Storage.FileStorage.LoadAsync(System.String)"/>
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.Extracted">
            <summary>
            Occurs when the current instance extracted all files by <see cref="M:Inertia.Storage.FileStorage.ExtractAllAsync(System.String)"/>
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.FolderAdded">
            <summary>
            occurs when all files from a folder are added by <see cref="M:Inertia.Storage.FileStorage.AddFolderAsync(System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.SaveProgress">
            <summary>
            Occurs when the save procedure progress
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.LoadProgress">
            <summary>
            Occurs when the load procedure progress
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.ExtractProgress">
            <summary>
            Occurs when the extraction procedure progress
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.AddFolderProgress">
            <summary>
            Occurs when adding folder procedure progress
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.SaveFailed">
            <summary>
            Occurs when the save procedure failed
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.LoadFailed">
            <summary>
            Occurs when the load procedure failed
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.ExtractFailed">
            <summary>
            Occurs when the extraction procedure failed
            </summary>
        </member>
        <member name="E:Inertia.Storage.FileStorage.AddingFolderFailed">
            <summary>
            Occurs when adding folder procedure failed
            </summary>
        </member>
        <member name="P:Inertia.Storage.FileStorage.Count">
            <summary>
            Return the number of files contained in the current instance
            </summary>
        </member>
        <member name="P:Inertia.Storage.FileStorage.Password">
            <summary>
            Get or set the password that will be used for the current instance
            </summary>
        </member>
        <member name="M:Inertia.Storage.FileStorage.#ctor">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.Storage.FileStorage"/>
            </summary>
        </member>
        <member name="M:Inertia.Storage.FileStorage.#ctor(System.String)">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.Storage.FileStorage"/>
            </summary>
            <param name="password">The password to use for the current instance</param>
        </member>
        <member name="M:Inertia.Storage.FileStorage.GetKeys">
            <summary>
            Return all the keys of all files contained by the current instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inertia.Storage.FileStorage.AddFolder(System.String,System.Boolean)">
            <summary>
            Add all files contained in the specified folder path
            </summary>
            <param name="folderPath">Folder path where to get files</param>
            <param name="inheritance">True if sub folders need to be added</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Storage.FileStorage.AddFolderAsync(System.String,System.Boolean)">
            <summary>
            Add all files contained in the specified folder path asynchronously
            </summary>
            <param name="folderPath">Folder path where to get files</param>
            <param name="inheritance">True if sub folders need to be added</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Storage.FileStorage.Remove(System.String)">
            <summary>
            Remove the file associated to the specified key from the current instance
            </summary>
            <param name="key">Target key to remove</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Storage.FileStorage.Extract(System.String,System.String)">
            <summary>
            Extract the file associated to the specified key in the specified folder path
            </summary>
            <param name="key">Key to extract</param>
            <param name="folderPath">Path where to save the file</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Storage.FileStorage.ExtractAll(System.String)">
            <summary>
            Extract all the files of the current instance in the specified folder path
            </summary>
            <param name="folderPath">Path where to save the file</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Storage.FileStorage.ExtractAllAsync(System.String)">
            <summary>
            Extract all the files of the current instance asynchronously in the specified folder path
            </summary>
            <param name="folderPath">Path where to save the file</param>
            <returns>The current instance</returns>
        </member>
        <member name="M:Inertia.Storage.FileStorage.GetData(System.String)">
            <summary>
            Get the data from a stored file informations in the current instance
            </summary>
            <param name="key">Target key from where to get the data</param>
            <returns>The data from the target file</returns>
        </member>
        <member name="M:Inertia.Storage.FileStorage.Save(System.String,System.String)">
            <summary>
            Save the current storage to the specified folder path using the specified file name
            </summary>
            <param name="folderPath">Folder path where to save the file</param>
            <param name="fileName">Target file name</param>
        </member>
        <member name="M:Inertia.Storage.FileStorage.SaveAsync(System.String,System.String)">
            <summary>
            Save asynchronously the current storage to the specified folder path using the specified file name
            </summary>
            <param name="folderPath">Folder path where to save the file</param>
            <param name="fileName">Target file name</param>
        </member>
        <member name="M:Inertia.Storage.FileStorage.Load(System.String)">
            <summary>
            Load the target file in the current storage
            </summary>
            <param name="filePath">File path to load</param>
        </member>
        <member name="M:Inertia.Storage.FileStorage.Load(System.Byte[])">
            <summary>
            Load the target data in the current storage
            </summary>
            <param name="data">Data to load</param>
        </member>
        <member name="M:Inertia.Storage.FileStorage.LoadAsync(System.String)">
            <summary>
            Load asynchronously the target file in the current storage
            </summary>
            <param name="filePath">File path to load</param>
        </member>
        <member name="M:Inertia.Storage.FileStorage.LoadAsync(System.Byte[])">
            <summary>
            Load asynchronously the target data in the current storage
            </summary>
            <param name="data">Data to load</param>
        </member>
        <member name="M:Inertia.Storage.FileStorage.Dispose">
            <summary>
            Dispose the current instance
            </summary>
        </member>
        <member name="T:Inertia.Storage.StorageProgressionEventArgs">
            <summary>
            Represent the progression of an event
            </summary>
        </member>
        <member name="F:Inertia.Storage.StorageProgressionEventArgs.TotalCount">
            <summary>
            Total elements in the progression
            </summary>
        </member>
        <member name="P:Inertia.Storage.StorageProgressionEventArgs.ProcessedCount">
            <summary>
            Total processed elements in the progression
            </summary>
        </member>
        <member name="P:Inertia.Storage.StorageProgressionEventArgs.PercentageProgression">
            <summary>
            Percentage of the current progression
            </summary>
        </member>
        <member name="T:Inertia.Storage.IStorage">
            <summary>
            Default storage class interface
            </summary>
        </member>
        <member name="M:Inertia.Storage.IStorage.Save(System.String,System.String)">
            <summary>
            Save the current storage to the specified folder path using the specified file name
            </summary>
            <param name="folderPath">Folder path where to save the file</param>
            <param name="fileName">Target file name</param>
        </member>
        <member name="M:Inertia.Storage.IStorage.SaveAsync(System.String,System.String)">
            <summary>
            Save asynchronously the current storage to the specified folder path using the specified file name
            </summary>
            <param name="folderPath">Folder path where to save the file</param>
            <param name="fileName">Target file name</param>
        </member>
        <member name="M:Inertia.Storage.IStorage.Load(System.String)">
            <summary>
            Load the target file in the current storage
            </summary>
            <param name="filePath">File path to load</param>
        </member>
        <member name="M:Inertia.Storage.IStorage.LoadAsync(System.String)">
            <summary>
            Load asynchronously the target file in the current storage
            </summary>
            <param name="filePath">File path to load</param>
        </member>
        <member name="M:Inertia.Storage.IStorage.Load(System.Byte[])">
            <summary>
            Load the target data in the current storage
            </summary>
            <param name="data">Data to load</param>
        </member>
        <member name="M:Inertia.Storage.IStorage.LoadAsync(System.Byte[])">
            <summary>
            Load asynchronously the target data in the current storage
            </summary>
            <param name="data">Data to load</param>
        </member>
        <member name="T:Inertia.InvalidPasswordException">
            <summary>
            Exception thrown when a file storage use a bad password
            </summary>
        </member>
        <member name="P:Inertia.InvalidPasswordException.Message">
            <summary>
            Get the message of the current exception
            </summary>
        </member>
        <member name="M:Inertia.InvalidPasswordException.#ctor">
            <summary>
            Initialize a new instance of the class <see cref="T:Inertia.InvalidPasswordException"/>
            </summary>
        </member>
        <member name="T:BasicAction">
            <summary>
            Execute code
            </summary>
        </member>
        <member name="T:BasicAction`1">
            <summary>
            Execute code with <typeparamref name="T"/> parameter
            </summary>
        </member>
        <member name="T:BasicAction`2">
            <summary>
            Execute code with multiples types parameters
            </summary>
        </member>
        <member name="T:BasicAction`3">
            <summary>
            Execute code with multiples types parameters
            </summary>
        </member>
        <member name="T:BasicAction`4">
            <summary>
            Execute code with multiples types parameters
            </summary>
        </member>
        <member name="T:BasicAction`5">
            <summary>
            Execute code with multiples types parameters
            </summary>
        </member>
        <member name="T:BasicReturnAction`1">
            <summary>
            Execute code with a <typeparamref name="R"/> returned object
            </summary>
        </member>
        <member name="T:BasicReturnAction`2">
            <summary>
            Execute code with a <typeparamref name="R"/> returned object and one <typeparamref name="T1"/> parameter
            </summary>
        </member>
        <member name="T:BasicReturnAction`3">
            <summary>
            Execute code with a <typeparamref name="R"/> returned object and multiples types parameters
            </summary>
        </member>
        <member name="T:BasicReturnAction`4">
            <summary>
            Execute code with a <typeparamref name="R"/> returned object and multiples types parameters
            </summary>
        </member>
        <member name="T:BasicReturnAction`5">
            <summary>
            Execute code with a <typeparamref name="R"/> returned object and multiples types parameters
            </summary>
        </member>
        <member name="T:BasicReturnAction`6">
            <summary>
            Execute code with a <typeparamref name="R"/> returned object and multiples types parameters
            </summary>
        </member>
        <member name="T:StorageUpdateFailedHandler">
            <summary>
            Storage event failing handler
            </summary>
            <param name="ex"></param>
        </member>
        <member name="T:StorageProgressHandler">
            <summary>
            Storage progression handler
            </summary>
            <param name="progress"></param>
        </member>
        <member name="T:NetworkDisconnectHandler">
            <summary>
            Network disconnecting handler
            </summary>
            <param name="reason"></param>
        </member>
        <member name="T:NetworkTcpClientConnectionCreatedHandler">
            <summary>
            Network transmission control protocol created handler
            </summary>
            <param name="connection"></param>
        </member>
        <member name="T:NetworkTcpClientConnectionDisconnectedHandler">
            <summary>
            Network transmission control protocol disconnected handler
            </summary>
            <param name="connection"></param>
            <param name="reason"></param>
        </member>
        <member name="T:NetworkGroupSenderHandler">
            <summary>
            Network group sender handler
            </summary>
            <param name="packet"></param>
        </member>
        <member name="T:NetworkUdpConnectionAddedHandler">
            <summary>
            Network user datagram added handler
            </summary>
            <param name="connection"></param>
        </member>
    </members>
</doc>
